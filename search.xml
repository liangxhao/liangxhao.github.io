<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Chapter 7: Multi-step Bootstrapping]]></title>
      <url>%2F2017%2F06%2F26%2FChapter-7-Multi-step-Bootstrapping%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章将蒙特卡洛方法和单步时序差分算法统一起来给出了更为一般的方法。 前两章所讲的是时序差分学习方法（TD）和蒙特卡洛方法（MC），其中one-step TD方法是走一步就更新估计值，MC方法是走完所有的步才更新估计值，本章将one-step TD扩展到multi-step TD的情况，走n步后更新估计值。 one-step方法每次更新的时间间隔相同，实际中我们可能需要根据状态改变的缓慢来调整value更新频率，multi-step可以实现在更长的时间间隔内更新。 n-step TD 预测 TD方法中的value在\(t\)时刻之后经过\(n\)步再更新的方法叫n-step TD。 考虑one-step TD和MC方法的backup diagram，可以扩展到\(n\)步的情况，如下图： figure 1 根据前两章one-step TD和MC的回报\(G_t\)的形式，可以扩展写出\(n\)步情况下的形式： \[ G_{t}^{\left( n \right)}=R_{t+1}+\gamma R_{t+2}+\cdot \cdot \cdot +\gamma ^{n-1}R_{t+n}+\gamma ^nV_{t+n-1}\left( S_{t+n} \right) \] 其中\(n\ge 1,0\le t\le T-n\)，当\(t+n\ge T\)，即n-step的回报超过终止状态时，多余部分的reward记为0，也就是说\(G_{t}^{\left( n \right)}=G_t\)。 此时就可以按照相同的方法立刻写出更新公式： \[ V_{t+n}\left( S_t \right) =V_{t+n-1}\left( S_t \right) +\alpha \left[ G_{t}^{\left( n \right)}-V_{t+n-1}\left( S_t \right) \right] \] error reduction property，n-step的期望回报值小于\(\gamma^n\)倍的\(V_{t+n-1}\)，保证了\(V\)在合适的条件下一定能收敛。 算法伪代码如下： figure 2 n-step Sarsa n-step方法也可以应用到控制问题中，例如Sarsa算法。 利用行为值写出n-step的回报值，如下： \[ G_{t}^{\left( n \right)}=R_{t+1}+\gamma R_{t+2}+\cdot \cdot \cdot +\gamma ^{n-1}R_{t+n}+\gamma ^nQ_{t+n-1}\left( S_{t+n},A_{t+n} \right) \] 其更新公式自然可以写出： \[ Q_{t+n}\left( S_t,A_t \right) =Q_{t+n-1}\left( S_t,A_t \right) +\alpha \left[ G_{t}^{\left( n \right)}-Q_{t+n-1}\left( S_t,A_t \right) \right] \] Expected Sarsa也可以推广过来，只需在最后\(G_{t}^{\left( n \right)}\)最后一项\(Q\)改为期望值即可，即： \[ G_{t}^{\left( n \right)}=R_{t+1}+\gamma R_{t+2}+\cdot \cdot \cdot +\gamma ^{n-1}R_{t+n}+\gamma ^n\sum_a{\pi \left( a|S_{t+n} \right)}Q_{t+n-1}\left( S_{t+n},a \right) \] 它们的backup diagram如下： figure 3 算法伪代码如下： figure 4 重要性采样下的n-step Off-policy 使用重要性采样的Off-policy方法也可以推广到n-step中。 其中重要性比率（importance sampling ratio）为如下形式： \[ \rho _{t}^{t+n}=\prod_{k=t}^{\min \left( t+n-1,T \right)}{\frac{\pi \left( A_k|S_k \right)}{\mu \left( A_k|S_k \right)}} \] 相当于从\(t\)到\(t+n-1\)时刻的action都是采样而来的。 则可以简单的用\(\rho\)作为权重，给出状态价值\(V\)的更新公式如下： \[ V_{t+n}\left( S_t \right) =V_{t+n-1}\left( S_t \right) +\alpha \rho _{t}^{t+n}\left[ G_{t}^{\left( n \right)}-V_{t+n-1}\left( S_t \right) \right] \] 行为价值\(Q\)的更新公式（即n-step Sarsa）如下： \[ Q_{t+n}\left( S_t,A_t \right) =Q_{t+n-1}\left( S_t,A_t \right) +\alpha \rho _{t+1}^{t+n}\left[ G_{t}^{\left( n \right)}-Q_{t+n-1}\left( S_t,A_t \right) \right] \] 注意这里的\(\rho\)是从\(t+1\)时刻开始。即\(t\)时刻的action是我们所要计算的，而不是采样而来的。 对于n-step Expected Sarsa来说，在最后一步用行为价值的期望替换了采样值，所以这里的\(\rho _{t+1}^{t+n}\)要改为\(\rho _{t+1}^{t+n-1}\)。 算法的伪代码如下： figure 5 不需要重要性采样的Off-policy: n-step Tree Backup算法 Q-learning和Expected Sarsa都可以在one-step的情况下不需要重要性采样而实现Off-policy，对于n-step的情况该如何做呢？ 这里给出一种tree-backup 的算法，如图是一个3-step backup diagram，这里以此为例进行说明。 figure 6 它是从一个action出发的state序列，每个state都要考虑它所有的action，策略\(\pi\)和行为价值。其中被选中的那个action需要特殊考虑，因为产生了下一个状态的样本，所以它不需要bootstrap。 每个不被选中的action需要用目标策略\(\pi\)的概率来加权它的行为价值，而那个被选中的action则需要对它产生的整个子树进行加权。 定义目标策略下的行为价值的期望值为： \[ V_t=\sum_a{\pi \left( a|S_t \right)}Q_{t-1}\left( S_t,a \right) \] TD error定义为： \[ \delta _t=R_{t+1}+\gamma V_{t+1}-Q_{t-1}\left( S_t,A_t \right) \] 则n-step的回报可写出如下公式： figure 7 式子中，由于V中多加了被选中action的那部分，所以在随后被减掉。 \(Q\)的更新公式和n-step Sarsa的相同。 算法外代码如下： figure 8 一个统一的算法：n-step Q(σ) 到目前为止，我们已经介绍了三种backup diagrams。n-step Sarsa算法的每一步都是采样转换，tree-backup 算法每一个分支都是状态-行为值转换，而n-step Expected Sarsa的最后一步是状态-行为转换，其它都是采样转换。 我们可以将这些情况统一起来，\(\sigma=0\)表示纯的期望值（状态行为转换），\(\sigma=1\)表示采样转换。如下图： figure 9 其中\(\rho\)表示在Off-policy的条件下，该处的转换需要重要性采样实现。 n-step Sarsa的回报可以写成依靠TD error的形式： \[ G_{t}^{\left( n \right)}=Q_{t-1}\left( S_t,A_t \right) +\sum_{k=t}^{\min \left( t+n-1,T-1 \right)}{\gamma ^{k-t}}\left[ R_{k+1}+\gamma Q_k\left( S_{k+1},A_{k+1} \right) -Q_{k-1}\left( S_k,A_k \right) \right] \] TD error可以写成带\(\sigma\)的形式： \[ \delta _t=R_{t+1}+\gamma \left[ \sigma _{t+1}Q_t\left( S_{t+1},A_{t+1} \right) +\left( 1-\sigma _{t+1} \right) V_{t+1} \right] -Q_{t-1}\left( S_t,A_t \right) \] 由此可以定义n-step回报值： figure 10 对于Off-policy，重要性采样比率被定义为： \[ \rho _{t}^{t+n}=\prod_{k=t}^{\min \left( t+n-1,T-1 \right)}{\left( \sigma _k\frac{\pi \left( A_k|S_k \right)}{\mu \left( A_k|S_k \right)}+1-\sigma _k \right)} \] 算法伪代码如下： figure 11]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 6: Temporal-Difference Learning]]></title>
      <url>%2F2017%2F06%2F26%2FChapter-6-Temporal-Difference-Learning%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章是在动态规划方法和蒙特卡洛方法的基础上给出了一种更为实用的策略计算方法——时序差分算法。 时序差分算法（TD）是MC与DP的结合，MC必须到等到episode结束时才更新value，而TD可以在每步episode中更新；MC没有用到马尔可夫性，即在估计某个value时没有利用到其它的value，而TD因此具有bootstrap。 TD预测 根据上一章介绍的蒙特卡洛方法可知，一个简单的蒙特卡洛方法可以写成如下形式： \[ V\left( S_t \right) \gets V\left( S_t \right) +\alpha \left[ G_t-V\left( S_t \right) \right] \] 其中\(\alpha\)是一个固定的步长，这种方法记为\(constant-\alpha\) MC。当一个episode结束时，\(G_t\)才是可知的。 由于 \[ v_{\pi}\left( s \right) =\mathbb{E}_{\pi}\left[ G_t|S_t=s \right] =\mathbb{E}_{\pi}\left[ R_{t+1}+\gamma v_{\pi}\left( S_{t+1} \right) |S_t=s \right] \] 所以MC可以与之结合，例如，TD(0)方法就是使用\(R_{t+1}+\gamma v_{\pi}\left( S_{t+1} \right)\)代替\(G_t\)，因而它具有bootstrap，就像DP算法那样，利用到了马尔科夫性，更新公式如下： \[ V\left( S_t \right) \gets V\left( S_t \right) +\alpha \left[ R_{t+1}+\gamma V\left( S_{t+1} \right) -V\left( S_t \right) \right] \] 算法流程如下： figure 1 TD error记为： \[ \delta _t=R_{t+1}+\gamma V\left( S_{t+1} \right) -V\left( S_t \right) \] 则MC的error经过计算可表示为： \[ G_t-V\left( S_t \right) =\sum_{k=0}^{T-t-1}{\gamma ^k}\delta _{t+k} \] TD(0)的backup diagram如下图： figure 2 TD预测方法的优点 TD算法是由MC和DP结合而来的，所以具有它们的优点。 TD不需要环境模型（奖励reward、状态转移概率） TD是即时的，即不需要等到episode完成时才能更新value TD(0)的优化 如果episodes的数量比较有限，那么每个episode的每个step只能更新一次value，为了尽量利用资源，提高优化效率，可以采用批更新方法（batch updating）。 方法是：每次完成一个episode就将其保存下来，随之每次都要根据所有保存的episode更新value。例如完成第10个episode时，就已经保存了10个，然后用这10个再更新value。 certainty-equivalence estimate：只要给定正确的模型，我们就可以估计出正确的value。这等价于假设潜在的过程是已知的，而非是估计而来的。 batch TD(0)正属于这种certainty-equivalence estimate。 TD算法比MC表现要好，batch MC实际上是最小化训练集的均方根误差，而batch TD则是最大化MDP模型的最大似然值。 Sarsa: On-Policy TD Control 我们依旧根据GPI的模式解决控制问题，Sarsa是属于On-policy的算法。 episode的状态行为序列为： figure 3 类似于预测问题，我们同样可以建立类似的更新方法： \[ Q\left( S_t,A_t \right) \gets Q\left( S_t,A_t \right) +\alpha \left[ R_{t+1}+\gamma Q\left( S_{t+1},A_{t+1} \right) -Q\left( S_t,A_t \right) \right] \] 这里涉及到了五元组$( S_t,A_t,R_{t+1},S_{t+1},A_{t+1} ) $，其backup diagram如下： figure 4 伪代码形式的算法流程如下图： figure 5 Q-learning: Off-Policy TD Control Q-learning是属于Off-policy的算法，它与Sarsa稍有不同，其更新公式如下： \[ Q\left( S_t,A_t \right) \gets Q\left( S_t,A_t \right) +\alpha \left[ R_{t+1}+\gamma \underset{a}{\max}Q\left( S_{t+1},a \right) -Q\left( S_t,A_t \right) \right] \] 伪代码形式的算法流程如下： figure 6 注意这里，off-policy与上面on-policy的不同：on-policy总是使用现有的（目标）策略（\(A\gets A&#39;\)），而off-policy则是重新选择新的\(A\)。 其backup diagram如下： figure 7 Expected Sarsa 在Q-learning中，用期望代替状态行为值的最大值，即为期望Sarsa算法。 \[ \begin{align} Q\left( S_t,A_t \right) &amp;\gets Q\left( S_t,A_t \right) +\alpha \left[ R_{t+1}+\gamma \mathbb{E}\left[ Q\left( S_{t+1},A_{t+1} \right) |S_{t+1} \right] -Q\left( S_t,A_t \right) \right] \\ &amp;\gets Q\left( S_t,A_t \right) +\alpha \left[ R_{t+1}+\gamma \sum_a{\pi \left( a|S_{t+1} \right)}Q\left( S_{t+1},a \right) -Q\left( S_t,A_t \right) \right] \end{align} \] 其backup diagram如下： figure 8 这几种算法在性能上有所差异，原书进行了一定对比。 例如Expected Sarsa可以安全地设置\(\alpha\)为1。而Sarsa则必须设置\(\alpha\)较小，而且需要长期的优化。 最大化偏差与两次学习 无论是Q-learning还是Sarsa（\(\epsilon -greedy\)）都有取最大值的操作，这会导致正的偏差。 例如真实值 $ q( s,a ) $ 是0，而它的估计值 $Q( s,a ) $ ，有时大于0，有时小于0，如果一直取最大值，那就会导致正的偏差。 一种解决方法是两次学习（Double Learning）。 假设我们把数据集划分为两部分，用它们估计两组独立的参数：$Q_1( a ) $ 和 $Q_2( a ) $。 用\(Q_1\)来找最大值的行为：$A^*=arg_a( Q_1( a ) ) $ 用\(Q_2\)来估计该行为的值：$Q_2( A^* ) =Q_2( arg_a( Q_1( a ) ) ) $ 则可以得到无偏估计：\(\mathbb{E}\)$[Q_2( A^* ) ] = q ( A^* ) $ 同样地过程也可以反过来做，即先用\(Q_2\)来找最大的行为，再用\(Q_1\)来估计该行为的值。 每个step只做其中的一个 这个思想是对MDPs的自然扩展，例如可以应用到Q-learning中去，其中\(Q_1\)更新公式为： \[ Q_1\left( S_t,A_t \right) \gets Q_1\left( S_t,A_t \right) +\alpha \left( R_{t+1}+\gamma Q_2\left( S_{t+1},\underset{a}{arg\max Q_1\left( S_{t+1},a \right) -Q_1\left( S_t,A_t \right)} \right) \right) \] \(Q_2\)的公式也是类似的，每次更新时，以0.5的概率随机选择1或者2. 算法流程如下： figure 9 Games, Afterstates, and Other Special Cases 上面介绍的算法都属于一个统一的方式，例如它们都涉及到求行为值函数。 然而第一章展示的TD算法用于求解井字游戏中更像是状态值函数，但仔细一看，它并非通常意义下的状态值函数，也不是行为值函数。 传统的状态值函数估计的是那些有机会选择行为的状态，而井字游戏中的状态值函数是在agent做了移动后才估计，我们称之为afterstates，相应的值函数叫做afterstates值函数。 afterstates值函数对于我们对初始部分已知但是没必要完全知道的情况有用处，例如游戏中我们知道每走一步的奖励，我们知道象棋每一步可能移动到的地方，但是我们不知道对手怎么回应。afterstates很自然的利用到这些知识。 传统的行为值函数把位置和移动映射到一个估计值，但是很多位置-移动对会产生相同的位置结果，如下面的例子： figure 10 afterstates会给出相等的value，但是传统的方法则不行。 afterstates在很多任务中十分普遍，这里不再细述，它仍然符合GPI框架。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 5: Monte Carlo Methods]]></title>
      <url>%2F2017%2F06%2F26%2FChapter-5-Monte-Carlo-Methods%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章介绍了在没有环境模型的条件下用来估计策略的蒙特卡洛方法。 上一章通过动态规划能够解决已知environment（即已知转移矩阵与reward函数）的MDP问题，根据是否已知policy可划分成prediction和control问题。 但是很多问题中environment是未知的，既不知道做了某个action之后会变到哪一个state，也不知道选择哪个action更好，也就是不知道environment的model是什么，在这种情况下需要解决的问题就是Model-free prediction和Model-free control。 显然这种新的问题只能从与environment的交互得到的experience中获取信息。 蒙特卡洛方法仅需要经验——与实际或者模拟环境进行交互的状态、行为和奖励的样本序列。 从实际环境中学习不需要事先了解环境的状态，仍然可以获得最优的行为。 从模拟环境中学习需要一个模型生成样本序列，然而上一章的DP算法则需要完整的概率分布。 在很多情况下，很容易根据概率分布来生成样本，而明确形式的概率分布却很难得到。 蒙特卡洛方法依靠样本回报的平均值来解决增强学习问题。 为了确保有明确的回报可用，这里定义蒙特卡洛方法仅用于情景性任务episode，情景完成时，价值估计和策略才会改变。 蒙特卡洛预测 首先计算策略估计（prediction问题），即计算在给定策略下的状态-价值函数。 一个显然的方法是，计算该状态之后回报的平均值，随着观测次数 的增多，平均值应收敛于期望值，这是所有蒙特卡洛方法的基础。 假设我们估计的是 \(v_{\pi}\)$ ( s ) $ 在一个情景episode下，每次出现状态\(s​\)，称为一个对\(s​\)的访问（visit），当然在同一个情景下 \(s​\) 可能会被访问多次，对\(s​\)的第一次访问称为first visit。 first-visit MC：使用episodes中第一次对 \(s\) 访问所得到的回报平均值来估计\(v_{\pi}\)$( s ) $. every-visit MC：使用episodes中所有对 \(s\) 访问后的回报平均值来估计\(v_{\pi}\)$( s ) $. 其中every-visit方法后面再讲，first-visit MC的算法流程如下图。 figure 1 例子：Blackjack游戏 与DP表达出所有可能的概率转换的backup diagram不同，蒙特卡洛的backup diagram只有情景任务的一个样本序列。episode需要执行到终止状态才能进行一次更新。 figure 2 蒙特卡洛估计行为值 除了状态-价值函数，还要估计行为-价值函数，这样才能从中选择出一个获得最大回报的行为。这和上一章DP算法中的做法是类似的。 假设我们估计的是 $q_{}( s,a ) $ ，所以这里需要考虑的是状态-行为对 state–action pair \((s,a)\)。 同样存在两种方法：first-visit MC和every-visit MC 问题是，可能有很多状态-行为对没有被访问过。如果\(\pi\)是一个确定性的策略，那么在每个状态下只有一个行为，其它的行为将不被访问到。这个问题属于maintaining exploration问题，可用如下方法解决。 exploring starts方法：使情景以一个state–action pair开始。在情景开始时，每个state–action pair都有非零的概率被选择到。 当然上述方法不是一直有效的，尤其是在实际环境中，我们可能没法选择起始条件。 蒙特卡洛控制 和上一章一样，这里广义策略迭代（generalized policy iteration）是解决这类最优策略问题的一般方法。这里不再赘述。 figure 3 \[ \pi_0 \xrightarrow{E} v_{\pi_0} \xrightarrow{I} \pi_1 \xrightarrow{E} v_{\pi_1} \xrightarrow{I} \pi_2 \xrightarrow{E} \cdots \xrightarrow{I} \pi_* \xrightarrow{E} v_* \] 这与上一章DP算法类似，实现的过程中有两种方案。一种类似于策略迭代，在每轮的策略估计中都尽可能逼近\(q_{\pi _k}\)，但这需要非常多的情景才能收敛到期望值；另一种类似于价值迭代，在策略估计未完成之时就就行策略提升，其中in place就是一种极端的方法。 ES版本的蒙特卡洛方法算法流程如下图： figure 4 不使用ES的蒙特卡洛控制 为了去掉exploring starts这个实际中不现实的假设，唯一的方法就是确保每个action可以被无限次的选择到。 有两种可选的方法：on-policy、off-policy on-policy估计和提高策略所使用的数据来自于该策略本身 off-policy估计和提高策略所使用的数据来自于其它策略 其实带有ES假设的方法也属于on-policy，下面去掉该假设。 on-policy控制方法一般都是柔性的（soft），意味着对于每个\(s\in \mathcal{S}\) 以及 \(a\in \mathcal{A}\)\((s)\) ，都有 \(\pi \left( a|s \right) &gt;0\) 来解决这个问题。 例如第二章提到的\(\epsilon\)-greedy策略就是soft的一个特例，选择action时有\(\epsilon\)的概率任意选择某个策略，而非总是选择当前最大回报的策略。这样在非贪婪时每个action被选择的最小概率是\(\frac{\epsilon}{\left| \mathcal{A}\left( s \right) \right|}\)，其中贪婪的那个action被选中的概率是\(1-\epsilon +\frac{\epsilon}{\left| \mathcal{A}\left( s \right) \right|}\)。下面是该算法的流程： figure 5 该方法的简要证明过程见原书。 重要性采样下的off-policy预测 所有的控制学习方法都面临着同一个矛盾：它们的目标是最终选择最优的行为，但是为了探索哪些是最优的，又不能总是选择那些当前看起来是最优的。 上一节的on-policy采用near-optimal policy这个接近最优的方法来解决该问题，而off-policy则更直接的采用两个策略：behavior policy和target policy behavior policy：行为策略，用来生成数据，做出更多的探索 target policy：目标策略，我们最终要学习的那个最优策略 off-policy比on-policy复杂，具有更高的方差，优化比较慢，但是它更强大，更具有通用性。on-policy也可以看作是off-policy的行为策略和目标策略相同下的特殊情况。 这里用\(\mu\)和\(\pi\)分别代表行为策略和目标策略。 为了使用\(\mu\)来估计\(\pi\)，必须要保证\(\pi\)下选择的action，在\(\mu\)下也会被选择到，即\(\pi \left( a|s \right) &gt;0\)成立时\(\mu \left( a|s \right) &gt;0\)也要成立，这称为优化假设。\(\mu\)是随机的、更具有探索性的，而\(\pi\)是确定具有贪婪性的策略。 off-policy一般通过重要性采样（importance sampling）来实现，它是通过一个样本分布估计另一个样本分布期望值的方法。 产生状态-行为值的轨迹子序列（subsequent state–action trajectory）\(A_t,S_{t+1},A_{t+1},...,S_T\)的策略\(\pi\)的概率是 \[ \prod_{k=t}^{T-1}{\pi \left( A_k|S_k \right)}p\left( S_{k+1}|S_k,A_k \right) \] 目标策略与行为策略的概率比值，即importance-sampling ratio为： \[ \rho _{t}^{T}=\frac{\prod\limits_{k=t}^{T-1}{\pi \left( A_k|S_k \right) p\left( S_{k+1}|S_k,A_k \right)}}{\prod\limits_{k=t}^{T-1}{\mu \left( A_k|S_k \right) p\left( S_{k+1}|S_k,A_k \right)}}=\sum_{k=t}^{T-1}{\frac{\pi \left( A_k|S_k \right)}{\mu \left( A_k|S_k \right)}} \] 重要性采样这个比值作为回报的加权值来估计价值函数。它仅仅用到两个策略的比值，并没有完全用到MDP。 假设有很多episode样本。将它们按顺序接在一块，例如第一个场景在时刻100结束，那第二个场景就在时刻101开始。 \(\mathfrak{J}\)$ ( s ) $ 表示所有访问状态\(s\)的时刻集合，$T( t ) $ 表示时刻\(t\)的终止状态时刻，\(G_t\) 表示从\(t\)到 $T( t ) $ 的回报。 有两种估计价值的方法： 一种是一般性的方法ordinary importance sampling： \[ V\left( s \right) =\frac{\sum_{t\in \mathcal{J}\left( s \right)}{\rho _{t}^{T\left( t \right)}G_t}}{\left| \mathcal{J}\left( s \right) \right|} \] 另一种带权值的方法是weighted importance sampling： \[ V\left( s \right) =\frac{\sum_{t\in \mathcal{J}\left( s \right)}{\rho _{t}^{T\left( t \right)}G_t}}{\sum_{t\in \mathcal{J}\left( s \right)}{\rho _{t}^{T\left( t \right)}}} \] 一般性的方法是无偏估计，但是方差是无界的。带权值的方法具有低方差性，效果更好。 增量实现 带权值的方法改写成如下形式： \[ V_n=\frac{\sum\limits_{k=1}^{n-1}{W_k}G_k}{\sum\limits_{k=1}^{n-1}{W_k}} \] 则可以在每个场景结束后通过增量更新的方式实现： \[ V_{n+1}=V_n+\frac{W_n}{C_n}\left[ G_n-V_n \right] \] 其中$C_{n+1}=C_n+W_{n+1} $ 由此可以总结算法流程如下： figure 6 Off-Policy蒙特卡洛控制 对于GPI这里不再赘述，直接给出流程，得到最优策略。 figure 7 特定回报值的重要性采样 上面所讲的方法仅仅对回报值进行加权处理，完全没有考虑回报值的内部结构，例如奖励的折扣率。 通过考虑这些问题可以减少off-policy估计的方差，这都还是当前比较前沿的研究。 例如episodes很长，而折扣 \(\gamma\) 远小于1。具体来说场景有100个时刻之长，而 \(\gamma =0\) ，那么 \(G_0=R_1\) ，则 \(\rho\) 的连乘形式中，只有第一项 \(\frac{\pi \left( A_0|S_0 \right)}{\mu \left( A_0|S_0 \right)}\) 与回报值有关，其它因子是完全独立的，而且期望值为1。 解决这个问题的一种方法是使用flat partial returns来计算上述重要性采样公式中的\(G_t\)。原理比较复杂，这里不再讨论。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Overcoming catastrophic forgetting in neural networks]]></title>
      <url>%2F2017%2F06%2F26%2FOvercoming-catastrophic-forgetting-in-neural-networks%2F</url>
      <content type="text"><![CDATA[论文解析：Kirkpatrick, J., Pascanu, R., Rabinowitz, N., Veness, J., Desjardins, G., Rusu, A. A., … Hadsell, R. (2016). Overcoming catastrophic forgetting in neural networks. arXiv Preprint. https://doi.org/10.1073/PNAS.1611835114 问题来源 实现通用人工智能的关键步骤是获得连续学习的能力，即agent必须能在不遗忘旧任务的执行方法的同时习得如何执行新任务。 McCloskey 和 Cohen（1989）首先注意到，先训练一个神经网络学会给一个数字加 1，然后再训练该神经网络学会给数字加 2，但之后该网络就不会给数字加 1 了。他们将其称为灾难性遗忘（catastrophic forgetting）。 因为神经网络往往是通过快速覆写来学习新任务，而这样就会失去执行之前的任务所必需的参数。 研究表明，哺乳动物大脑的学习能力是通过突触后树突棘（postsynaptic dendritic spines）随时间而进行的形成和消除而实现的。尽管大多数新形成的树突棘后面都消失了，但仍有一小部分保留了下来，当特定的树突棘被擦除时，其对应的技能也会随之消失。 这些实验说明连续学习依赖于任务的突触巩固，知识通过一部分突触更少塑性而获得持久编码。 本文探讨了类似的办法，根据神经元的重要性来来改变单个神经元的可塑性，初步给出了解决问题的可能方法。 推导演示 神经网络的学习就是调整权重以得到更好的输出。对于大型网络，许多不同的参数可以得到相似的结果，也就是神经网络的过参数化。 假设神经网络按顺序学习两个任务 A 和 B，参数记为\(\theta\)，可以利用过参数化，使任务 B 的参数尽可能接近于任务 A。 figure 1 \(\theta_A\)代表在 A 任务中表现最好的 \(\theta\) ，灰色区域表示的参数集合都可以接近于这个表现。 如果神经网络随后学习任务 B ，则将在蓝色箭头的方向上移动，获得任务B的参数区域。如果移动的过程中施加权重约束，可能得到绿色的移动方向，不仅不能很好的学习任务B，任务A的记忆也不能很好保留。 最好的办法是根据参数对任务的重要程度来选择其固化的程度，使得参数沿红色箭头移动，找到同时能够很好执行任务 A 和 B 的参数。 作者称这种方法为弹性权重巩固（Elastic Weight Consolidation）。 假设我们有一些数据 D，希望找到最可能的参数 \(\theta\) ，其条件概率为： \[ p\left( \theta |D \right) =\frac{p\left( D|\theta \right) p\left( \theta \right)}{p\left( D \right)} \] 写成对数似然的形式： \[ \log p\left( \theta |D \right) =\log p\left( D|\theta \right) +\log p\left( \theta \right) -\log p\left( D \right) \] 假设D由两个独立部分构成，\(D_A\)和\(D_B\)分别是用于A、B任务的数据。则可得： \[ p\left( D|\theta \right) =p\left( D_A|\theta \right) p\left( D_B|\theta \right) \] 代入上一个式子，可得： \[ \log p\left( \theta |D \right) =\log p\left( D_B|\theta \right) +\log p\left( \theta |D_A \right) -\log p\left( D_B \right) \] 等式左边仍然表示的是整个数据集下计算参数的后验概率。 式右边仅仅取决于\(B\)的损失函数，$p ( D_B|θ ) $ 。所有关于\(A\)的信息都保留在后验概率 $p( θ|D_A ) $ ，它可以告诉我们哪些参数在解决A时很重要。 为了实现EWC，后验概率必须包含哪些参数对于\(A​\)是重要的信息。真实的后验概率是不可知的，这里使用高斯分布进行估计，均值为\(\theta _{A}^{*}​\)，方差由Fisher信息矩阵\(F​\)给定。 $Fisher $信息是一种测量可观察随机变量 X 携带的关于 X 所依赖的概率的未知参数θ的信息的量的方法。我们需要测量来自 \(D_A\)的每个数据所携带的关于\(\theta\)的信息的量。 \(F\)的公式引自于另一篇论文，如下： \[ \mathbf{F}_{\theta}=E\left[ \left( \nabla \log p_{\theta}\left( \mathbf{z} \right) \right) ^T\left( \nabla \log p_{\theta}\left( \boldsymbol{z} \right) \right) \right] \] \(F\)满足三个属性： 它等价于损失函数接近于最小值的二阶导数； 它能通过一阶导数单独计算，对于非常大的模型也能简单计算； 它是半正定的； 这种方法类似于期望传播，其中每个子任务都可被视为后验因素。 在这种估计下，学习任务A后，对于任务B的EWC最小化的损失函数\(L\)是： \[ L\left( \theta \right) =L_B\left( \theta \right) +\sum_i{\frac{\lambda}{2}}F_i\left( \theta _i-\theta _{A,i}^{*} \right) ^2 \] 其中$ L_B (θ) $ 是\(B\)的损失，\(\lambda\) 表示旧任务相对于新任务的重要性。 对于第三个任务C，EWC将尝试保持网络参数接近于A、B学习的参数。这通过两种方法实现，一是通过两个单独的惩罚项，二是两个二次惩罚之和作s为新的二次惩罚。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Feedback Networks]]></title>
      <url>%2F2017%2F06%2F26%2FFeedback-Networks%2F</url>
      <content type="text"><![CDATA[论文解析：Zamir, A. R., Wu, T.-L., Sun, L., Shen, W., Malik, J., &amp; Savarese, S. (2016). Feedback Networks. Retrieved from http://feedbacknet.stanford.edu/ 概要 目前在计算机视觉领域，最成功的学习模型一般都是学习连续的特征表示（successive representations），然后使用一个决策层（decision layer）进行分类或者识别。这种模型一般可以通过多层前馈网络实现，如ConvNets，其中的每一层都是连续特征表示的一部分。但是用反馈的方法也可以达到相同的效果，通过多次迭代，前一次迭代得到输出，反馈输入到模型中，得到下一次的输出，从而得到多个连续的特征表示。 反馈模型有以下优势： Early Predictions：可以得到早期的预测结果； Taxnomoy Compliance：输出结果符合类别的分层结构； Episodic Curriculum Learning：提供了新的理论基础； 作者提出了基于反馈的一般学习模型，其测试结果比目前的前馈网络相当甚至更好，此外，作者还给出了并行化实现的方法，探究了反馈结构和模型设计的不同机制。 详细内容 优势 Early Predictions。 反馈结构中只有当信号传到网络最后一层时才给出预测结果，而在反馈网络中可以在迭代中预测。如下图，第一次预测出是载具，第二次预测出是有轮载具，第三次预测出自行车，第四次预测出山地自行车。 figure 1 Taxnomoy Compliance。 上述每次的预测结果符合从粗到细的分类结构。 Episodic Curriculum Learning。 Curriculum Learning在机器学习系统或者人类教育上都是一种重要的途径。在非凸优化问题上它帮助找到更好的最小值点，在优化问题上它可以加快优化速度。 前馈网络的预测结果是一次性的，所以要进行Curriculum Learning的话，必须要根据复杂度把训练数据赋予一个相同完整的网络，把不同的Curriculum安插在每一次测试当中（比如第一次训练给一些简单的例子，以后几次再给难一些的）。而反馈学习模型可以将Curriculum安插在一次测试中的任何一段，称为Episodic Curriculum Learning。 方法 作者给出了以循环神经网络（RNN）为基础的反馈模型的设计方法。 这里以ConvLSTM为例，完成进行图像分类的任务。 ConvLSTM就是用卷积操作代替LSTM的每一个元胞（Cell），LSTM的元胞结构如下，这里不再赘述。 figure 2 反馈预测可通过ConvLSTM模型实现，具体如下： 在LSTM的每个时刻\(t\)，输入为图像，用卷积代替\(cell\)操作后，输出也为图像。增加图像一般的后处理过程（例如pooling, fully connected layer等），得到\(t\)时刻的交叉熵损失\(L_t\)，总的损失函数为各个时刻的损失之和，其中\(\gamma\)是是折扣系数； \[ L=\sum_{t=1}^T{\gamma ^tL_t},\ where\ L_t=-\log \frac{e^{H_{t}^{D}\left[ C \right]}}{\sum_j{e_{t}^{D}\left[ j \right]}} \] 各个时刻的卷积参数\(W\)是共享的，每个时刻都进行反向传播训练； 将网络的各个时刻展开如下图所示，其中红色箭头表示skip connections（类似于ResNet） figure 3 作者提出的网络结构非常灵活，可以选择ConvLSTM模块中前馈网络的数量或者用不同数目的ConvLSTM模块进行堆叠。我们可以根据单个ConvLSTM模块中前馈层(Conv + BN)的数量对反馈网络进行分类。例如下图所示。分别记为Stack-1，Stack-2，Stack-All，其中Stack-i表示ConvLSTM中有\(i\)个前馈层，这决定了隐藏状态在整个网络上的分布。 figure 4 网络的一些细节如下： Temporal Skip Connection。忽略连接，设\(t\)表示第\(t\)时刻，\(d\)表示网络的深度（Physical Depth），则\(t\)时刻，跳过的长度为\(n\)，则新输入可表示为： \[ \widehat{X_{t}^{d}}=X_{t}^{d}+H_{t-n}^{d} \] Taxonomic Prediction。反馈网络系统可以在迭代过程中给出预测，早期是粗略的分类，随着迭代的进行，可以实现精细的分类。根据Softmax中的定义，识别对象属于某一类的概率： \[ P\left( y_i|x;W \right) =\frac{e^{f_{y_i}}}{\sum_j{e^{f_j}}} \] 则它属于更高级的大类别的概率可以表示为其中各个小类的概率之和： \[ P\left( Y_k|x;W \right) =\sum_{i\in 1:n}{P\left( y_i|x;W \right)} \] Episodic Curriculum Learning。反馈网络在第\(k\)次迭代过程中采用退火损失函数，则在第\(t\)次粗分类与细分类损失函数可表示为： \[ L\left( t \right) =\varsigma L_t^{Coarset}+\left( 1-\varsigma \right) L_t^{Fine} \] 其中\(\varsigma =\frac{t}{k}\)，\(t=0,1,2,...,k\)，采用线性衰退的形式。 Computation Graph Analysis。设网络\(m\)为迭代次数，\(n\)为物理深度。则前馈的深度为\(mn-1\)，反馈的深度为\(m+n-1\)，计算图如下，关于硬件并行方面的实现这里不细述。 figure 5]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 4: Dynamic Programming]]></title>
      <url>%2F2017%2F04%2F18%2FChapter-4-Dynamic-Programming%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章介绍了求解马尔科夫决策过程的基本算法：动态规划。总结出了解决增强学习问题的一般模型：广义策略迭代。 动态规划（DP）是假设环境完美满足MPD模型并计算其最优策略的一类算法。 由于经典的DP算法假设了完美的模型，而且计算量大，所以使用范围很有限，但是它为增强学习提供了必要的理论基础。 DP算法以及一般的增强学习问题的核心就是利用值函数构造搜索方式以得到最优策略。 最优值函数\(v_*\)和\(q_*\)满足最优贝尔曼等式： \[ \begin{aligned} v_*\left( s \right) &amp;=\underset{a}{max}\,\,\mathbb{E}\left[ R_{t+1}+\gamma v_*\left( S_{t+1} \right) \,\,|\,\,S_t=s,A_t=a \right]\\ &amp;=\underset{a}{max}\sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma v_*\left( s&#39; \right) \right]\\ q_*\left( s,a \right) &amp;=\mathbb{E}\left[ R_{t+1}+\gamma \underset{a&#39;}{\max}q_*\left( S_{t+1},a&#39; \right) \,\,|\,\,S_t=s,A_t=a \right]\\ &amp;=\sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma \underset{a&#39;}{\max}q_*\left( s&#39;,a&#39; \right) \right]\\ \end{aligned} \] 策略评估 对于任意给定的策略\(\pi\)，计算其状态-值函数\(v_{\pi}\)，称为策略评估（Policy Evaluation）。我们也称之为预测问题（prediction problem）。 下面这个是上一章给出的状态-值函数公式： \[ \begin{aligned} v_{\pi}\left( s \right) &amp;\doteq \mathbb{E}_{\pi}\left[ \sum_{k=0}^{\infty}{\gamma}^kR_{t+k+1}|S_t=s \right]\\ &amp;=\sum_a{\pi}\left( a|s \right) \sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma v_{\pi}\left( s&#39; \right) \right] ,\,\,\forall s\in \mathcal{S}\\ \end{aligned} \] 可以看出状态\(s\)的值\(v_{\pi}\)，是由其它状态\(s&#39;\)决定的，如果环境是完全已知的，则上式可以通过线性方程直接求解： \[ v_{\pi}=R^{\pi}+\gamma P^{\pi}v_{\pi} \] 实际情况下我们一般采用迭代方式求解。 从给定的初始值\(v_0\)开始，估计一系列值\(v_0,v_1,v_2,...\)，最终收敛到\(v_{\pi}\)。下面是更新公式： \[ \begin{aligned} v_{k+1}\left( s \right) &amp;=\mathbb{E}_{\pi}\left[ R_{t+1}+\gamma v_k\left( S_{t+1} \right) \,\,|\,\,S_t=s \right]\\ &amp;=\sum_a{\pi}\left( a|s \right) \sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma v_k\left( s&#39; \right) \right] ,\,\,\forall s\in \mathcal{S}\\ \end{aligned} \] 更新的停止条件一般是判断\(\max _{s\in S}\left| v_{k+1}\left( s \right) -v_k\left( s \right) \right|\)是否足够小。这种方法被称为迭代策略评估（iterative policy evaluation） 对每个\(s\)利用\(v_k\left( s \right)\)来更新\(v_{k+1} \left( s \right)\)，更新完所有的\(s\)就是迭代一次，然后用\(v\)新值取代旧值，进入下一次迭代，这种方法称为full backup，实现过程中使用两个数组，\(v_k\left( s \right)\)作为旧值数组，\(v_{k+1} \left( s \right)\)作为新值数组。 另一种更容易是in place，它与上述公式的原理有略微不同，有着更快的收敛速度。只使用一个数组，每次迭代就扫面（sweep）一遍状态\(s\)，然后立刻更新\(v_k\left( s \right)\)。 下面是in place版本的算法描述： figure 1 策略提升 我们计算值函数的目的是找到最好的策略。 前面计算的是某一任意策略\(\pi\)下的值函数，我们想知道是在某些状态\(s\)时，否应该改变这个策略，从中选出一个行动$a( s ) $，在此行动下可以得到更好的值（这称为Policy Improvement）。 从上一章可以知道行动-值函数的公式如下： \[ \begin{aligned} q_{\pi}\left( s,a \right) &amp;=\mathbb{E}_{\pi}\left[ R_{t+1}+\gamma v_{\pi}\left( S_{t+1} \right) \,\,|\,\,S_t=s,A_t=a \right] \\\ &amp;=\sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma v_{\pi}\left( s&#39; \right) \right] \end{aligned} \] 可以证明一定存在\(a=\pi&#39;\left(s\right)\)，使得值函数取得最大，证明过程参见原文，称之为policy improvement theorem。 实际上就是贪婪策略（greedy policy），每次取\(a\)使得值函数达到最大。 \[ \begin{align} \pi&#39;(s) &amp; = \underset{a}{argmax} \ q_{\pi}(s, a) \\ &amp; = \underset{a}{argmax} \ \sum_{s&#39;, r} p(s&#39;,r|s,a) \left [ r + \gamma v_{\pi}(s&#39;) \right ] \end{align} \] 策略迭代 策略迭代（Policy Iteration）就是不断重复策略评估和策略提升的过程，以找到最优的策略。 Generalized Policy Iteration 广义策略迭代 \[ \pi_0 \xrightarrow{E} v_{\pi_0} \xrightarrow{I} \pi_1 \xrightarrow{E} v_{\pi_1} \xrightarrow{I} \pi_2 \xrightarrow{E} \cdots \xrightarrow{I} \pi_* \xrightarrow{E} v_* \] 动态规划的基本思想 - 通用策略迭代是： 从一个策略\(\pi_0\)开始； 策略评估， 得到策略\(\pi_i\)的价值\(v_{\pi _i}\)； 策略提升， 根据价值价值\(v_{\pi _i}\)，优化策略为\(v_{\pi _{i+1}}\)； 迭代上面的步骤2和3，直到找到最优值\(v_*\)，并得到最优策略\(\pi_*\)； 终止条件：得到了稳定的策略\(\pi\)和价值\(v_{\pi}\)。 算法流程描述如下： figure 2 价值迭代 策略迭代的收敛过程是比较缓慢的，必须等待策略评估完成后才能进行策略提升。 实际上策略评估在收敛之前每次迭代所得到的状态-值函数，其对应的贪婪策略可能就已经稳定不变了，所以我们基于此做出简化，可以优化到相同的结果。在策略评估过程中，对于每个状态\(s\)，只找最优行动\(a\)，称之为价值迭代（Value Iteration）。 \[ \begin{aligned} v_{k+1}\left( s \right) &amp;\doteq \underset{a}{max}\,\,\mathbb{E}\left[ R_{t+1}+\gamma v_k\left( S_{t+1} \right) \,\,|\,\,S_t=s,A_t=a \right]\\ &amp;=\underset{a}{max}\,\,\sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma v_k\left( s&#39; \right) \right]\\ \end{aligned} \] 算法流程描述如下： figure 3 异步动态规划 上面所讨论的算法计算量极其庞大。很多实际问题的状态空间，例如双陆琪游戏的状态空间可能高达\(10^{20}\)，扫描一次可能需要上千年时间。 异步DP算法需要在每个并行单元保存所有状态值，可以非常灵活而且有效的减少计算量。 以下是三个简单的异步DP算法： In-place dynamic programming Prioritised sweeping Real-time dynamic programming 广义策略迭代 广义策略迭代（generalized policy iteration，GPI）是策略评估与策略提升这两个过程交互的一般思想，这与过程的粒度等其它细节无关。几乎所有的增强学习问题都可以用GPI描述。 GPI可以被看作竞争与合作的关系。它们在相反的方向上竞争，贪婪的选择策略后会使值函数发生改变，值函数再进行调整以使值与策略相一致，再长期作用下，可以得到一个单一的联合解决方案：最优值函数和最优策略。 figure 4 策略评估与策略提升之间交互，为了共同的目标。 figure 5 下表是一个总结： Problem Bellman Equation Algorithm Prediction Bellman Expectation Equation Iterative Policy Evaluation Control Bellman Expectation Equation+Greedy Policy Improvement Policy Iteration Control Bellman Optimality Equation Value Iteration 动态规划的效率 DP对于非常大的问题可能并不实用，但与其他解决MDP的方法相比，DP方法实际上是很有效的。 DP的时间复杂度是关于状态数\(k\)和动作数\(n\)的多项式。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 3: Finite Markov Decision Processes]]></title>
      <url>%2F2017%2F04%2F18%2FChapter-3-Finite-Markov-Decision-Processes%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章介绍了增强学习问题的基本模型，引入了马尔科夫决策过程和贝尔曼方程，这是以后解决增强学习问题的基础。 先建立描述增强学习问题的数学化形式，进行精确地理论陈述。 代理-环境接口 The Agent–Environment Interface. 代理（agent）：学习者或者决策者 环境（environment）：代理之外的一切，并与代理交互。 figure 1 代理与环境在离散时间序列中进行交互。在时刻\(t\)，代理收到环境状态（state）的表达\(S_t\)，\(S_t\in S\)，\(S\)是所有状态可能的集合。代理选择一个动作\(A_t\)，\(A_t \in A\left( S_t \right)\)，其中\(A\left( S_t \right)\)是在状态\(S_t\)下所有可用动作的集合。下一个时刻，代理将会收到将会收到一个数值的奖励\(R_t\)，并且收到一个新的状态\(S_{t+1}\)。 情景性任务与连续性任务 情节性任务(Episodic Tasks)，所有的任务可以被可以分解成一系列情节。逻辑上，可以看作为有限步骤的任务。 连续任务(Continuing Tasks) ，所有的任务不能分解。可以看作为无限步骤任务。 目标与奖励 目标（goal）：代理的目标是最大化它在长时间内所收到的所有奖励之和。 设代理在时刻\(t\)后收到的奖励分别为\(R_{t+1}\)，\(R_{t+2}\)，\(R_{t+3}\)…… 那么在\(t\)时刻的目标是： 情节性任务 \[ G_t\doteq R_{t+1}+R_{t+2}+\cdot \cdot \cdot +R_T \] 连续性任务 \[ G_t\doteq R_{t+1}+\gamma R_{t+2}+\gamma ^2R_{t+3}\cdot \cdot \cdot =\sum_{k=0}^{\infty}{\gamma ^kR_{t+k+1}} \] 其中\(0\le \gamma \le 1\)称为折扣系数。 为了简单，可以将这两种任务统一起来进行表达，如下图，可以认为情节性任务中代理进入终止状态以后，每个时刻收到的奖励都为0。 figure 2 统一之后的表达式如下： \[ G_t\doteq \sum_{k=0}^{T-t-1}{\gamma ^kR_{t+k+1}} \] 其中$T=\(或者\)=1$。 马尔科夫属性 一般情况下环境在\(t+1\)时刻的响应（状态\(s&#39;\)、奖励\(r\)）是由迄今为止所有的状态、行动和奖励决定的，可以用联合概率分布来表示： \[ Pr\{S_{t+1} = s&#39;, R_{t+1} = r | S_0, A_0, R_1, S_1, A_1, \dots, R_t, S_t, A_t \} \] 一个状态如果能够保留历史上所有相关的状态信号，则称它具有马尔科夫属性。 例如棋盘上所有棋子当前的状态，虽然之前很多序列的信息都丢失了，但是对于下一步真正重要的一切都有保留。 所以如果状态具有马尔科夫属性，那么上式就可以简化为如下形式： \[ p(s&#39;, r | s, a) = Pr \{S_{t+1} = s&#39;, R_{t+1} = r | S_t = s, A_t = a \} \] 如果一个环境具有马尔科夫属性的话，在给定当前状态和行动后就可以预测下一个时刻的状态和奖励。通过迭代该式，就可以预测所有未来时刻的状态和奖励，甚至求出完整的历史信息。 马尔科夫决策过程 一个增强学习任务如果满足马尔科夫属性，那么就称之为马尔科夫决策过程（MDP）。如果状态和动作空间是有限的，则称之为有限马尔科夫决策过程（finite MDP）。 在状态\(s\)下，执行行动\(a\)，转变为状态\(s&#39;\)并获得奖赏\(r\)的可能性： \[ p(s&#39;, r | s, a) \doteq Pr \{S_{t+1} = s&#39;, R_{t+1} = r | S_t = s, A_t = a \} \] 在给定上式后就可以计算任何想知道的环境信息，例如： state-action pairs，在状态\(s\)下，执行动作\(a\)的期望奖励： \[ r(s,a) \doteq \mathbb{E}[R_{t+1} | S_t = s, A_t = a] = \sum_{r \in \mathcal{R}} r \sum_{s&#39; \in \mathcal{S}} p(s&#39;, r|s,a) \] state-transition probabilities，在状态\(s\)下，执行行动\(a\)，转变为状态\(s&#39;\)的可能性： \[ p\left( s&#39;|s,a \right) \doteq Pr\{S_{t+1}=s&#39;|S_t=s,A_t=a\}=\sum_{r\in \mathcal{R}}{p}\left( s&#39;,r|s,a \right) \] expected rewards for state–action–next-state triples，在状态\(s\)下，执行行动\(a\)，转变为状态\(s′\)的期望奖赏： \[ r\left( s,a,s&#39; \right) \doteq \mathbb{E}\left[ R_{t+1}|S_t=s,A_t=a,S_{t+1}=s&#39; \right] =\frac{\sum_{r\in \mathcal{R}}{r}p\left( s&#39;,r|s,a \right)}{p\left( s&#39;|s,a \right)} \] 例如一个回收机器人的例子。在每个时刻，机器人有三种选择： （1）主动搜索罐头 （2）保持静止，等待有人带来罐头 （3）原路返回去充电 最好的方式是主动搜索罐头，但这会导致它耗尽电量而关机，而等待的过程不会耗电。如果机器人关机的话，那就会有人来重启它。 状态集合\(S=\{ high,low \}\)，可能的行动有wait，search，recharge，则agent的行为集合是 \[ \begin{align} A \left( high \right) &amp;\doteq \{search,wait\} \\\ A \left( low \right) &amp;\doteq \{search,wait,recharge\} \end{align} \] 具体信息参见原文，可以建立如下表格。 figure 3 转换图： figure 4 值函数 策略\(\pi\)是状态\(s\)的映射，\(\pi \left( a| s \right)\)是在状态\(s\)下采取动作\(a\)的概率。 状态值函数，state-value function for policy \(\pi\) 在策略\(\pi\)下状态\(s\)的值函数，定义为\(v_{\pi} \left(s\right)\). \[ v_{\pi}(s) \doteq \mathbb{E}[G_t | S_t = s] = \mathbb{E}_{\pi} \left [ \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} | S_t = s \right ] \] 行动值函数，action-value function for policy \(\pi\) 类似的定义，在策略\(\pi\)状态\(s\)采取行动\(a\)的值函数，定义为\(q_{\pi} \left(s,a\right)\). \[ q_{\pi}(s,a) \doteq \mathbb{E}[G_t | S_t = s, A_t = a] = \mathbb{E}_{\pi} \left [ \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} | S_t = s, A_t = a \right ] \] 值函数满足递归性质，设\(s&#39;\)表示下一时刻的状态，（迭代状态值函数）推导如下： \[ \begin{align} v_{\pi}(s) &amp; \doteq \mathbb{E}[G_t | S_t = s] \\ &amp; = \mathbb{E}_{\pi} \left [ \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} | S_t = s \right ] \\ &amp; = \mathbb{E}_{\pi} \left [ R_{t+1} + \gamma\sum_{k=0}^{\infty} \gamma^k R_{t+k+2} | S_t = s \right ] \\ &amp; = \sum_{a} \pi(a|s) \sum_{s&#39;} \sum_{r} p(s&#39;,r|s,a) \left [ r + \gamma\mathbb{E}_{\pi} \left [ \sum_{k=0}^{\infty} \gamma^k R_{t+k+2} | S_{t+1} = s&#39; \right ] \right ] \\ &amp; = \sum_{a} \pi(a|s) \sum_{s&#39;,r} p(s&#39;,r|s,a) \left [ r + \gamma v_{\pi}(s&#39;) \right ], \ \forall s \in \mathcal{S} \end{align} \] 上式就是关于\(v_{\pi}\)的Bellman equation。 Backup diagrams，图形化可以表示如下： figure 5 最优值函数 解决增强学习问题，就是寻找策略以在长期内获得很多奖励。 对于有限MDP，可以精确的定义这个问题。存在一个最优的策略\(\pi_*\)，它得到的value总是比其它策略更多。 在该策略下的值函数，称为最优值函数。 最优状态值函数，optimal state-value function： \[ v_*(s) \doteq \underset{\pi}{max} \ v_{\pi}(s), \forall s \in \mathcal{S} \] 最优行动值函数，optimal action-value function： \[ q_*(s) \doteq \underset{\pi}{max} \ q_{\pi}(s, a), \ \forall s \in \mathcal{S} \ and \ a \in \mathcal{A}(s) \] 最优行动值函数等于最优状态值函数下的最大期望： \[ q_*(s,a) = \mathbb{E}[R_{t+1} + \gamma v_* (S_{t+1}) \ | \ S_t = s, A_t = a] \] Bellman Optimality equation 同理，最优值函数也满足迭代性质。 \[ \begin{align} v_*(s) &amp; = \underset{a \in \mathcal{A}(s)}{max} \ q_{\pi_*}(s, a) \\ &amp; = \underset{a}{max} \ \mathbb{E}_{\pi*} [G_t \ | \ S_t=s, A_t=a] \\ &amp; = \underset{a}{max} \ \mathbb{E}_{\pi*} \left [ \sum_{k=0}^{\infty} \gamma^k R_{t+k+1} \ | \ S_t=s, A_t=a \right ] \\ &amp; = \underset{a}{max} \ \mathbb{E}_{\pi*} \left [ R_{t+1} + \gamma\sum_{k=0}^{\infty} \gamma^k R_{t+k+2} \ | \ S_t=s, A_t=a \right ] \\ &amp; = \underset{a}{max} \ \mathbb{E}[R_{t+1} + \gamma v_*(S_{t+1}) \ | \ S_t=s, A_t=a ] \\ &amp; = \underset{a \in \mathcal{A}(s)}{max} \sum_{s&#39;,r} p(s&#39;,r|s,a)[r + \gamma v_*(s&#39;)] \\ \end{align} \] 上式就是关于\(v_*\)的Bellman equation。 同样关于\(q_*\)的Bellman equation如下： \[ \begin{aligned} q_*\left( s,a \right) &amp;=\mathbb{E}\left[ R_{t+1}+\gamma \underset{a&#39;}{\max}q_*\left( S_{t+1},a&#39; \right) \,\,|\,\,S_t=s,A_t=a \right]\\ &amp;=\sum_{s&#39;,r}{p}\left( s&#39;,r|s,a \right) \left[ r+\gamma \underset{a&#39;}{\max}q_*\left( s&#39;,a&#39; \right) \right]\\ \end{aligned} \] Backup diagrams，图形化可以表示如下： figure 6 通过贝尔曼最优等式，可以解决回收机器人的问题： figure 7 figure 8 优化和近似 得到最优策略需要极大的计算量和内存，需要进行优化和近似估计。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 2: Multi-arm Bandits]]></title>
      <url>%2F2017%2F04%2F18%2FChapter-2-Multi-arm-Bandits%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章以多臂赌博机为例，介绍了增强学习所涉及的一些基本概念与学习方法。 增强学习能够从训练信息中评价所采取的行动，而不是以正确的行动作为指导，这是与其它类型学习的重要区别之一。 这两种方式分别称为评价性反馈和指导性反馈，评价性反馈取决于所采取的行动，指导性反馈与所采取的行动无关。 k-armed bandit问题是评价性反馈的一个简单版本，这里以此来介绍一些基本的学习方法。 多臂赌博机问题 假设有\(k\)个老虎机并排放在我们面前，每一轮，我们可以选择一个老虎机来按，同时记录老虎机给出的奖励。假设各个老虎机不是完全相同的，经过多轮操作后，我们可以勘探出各个老虎机的部分统计信息,然后选择那个看起来奖励最高的老虎机。 基本概念 在\(k\)个选择（行动）中，每个选择都有一个期望奖励，这里称之为the value of action。 在第\(t\)次行动中，我们的行动记为\(A_t\)，其奖励记为\(R_t\) 在做了行动\(a\)后，奖励的期望（true value）为$q_*( a ) $，即： \[ q_*\left( a \right) =E\left[ R_t|A_t=a \right] \] 如果我们已经知道了选择每个老虎机的奖励，那么只需要选择奖励最高的那个老虎机即可。 但是在实际中奖励值是不可知的，需要通过多次实验进行估计。 在第\(t​\)次行动，动作为 \(a​\) 时，我们用 \(Q_t\left( a \right) ​\) 来估计 \(q_*​\)\(\left( a \right) ​\) ，即 \(Q_t\left( a \right)\) \(\approx\) \(q_*\left( a \right)\) 行动-价值方法 估计行动\(a\)的奖励的期望，最自然的方法就是使用多次奖励的平均值。 \[ Q_t\left( a \right) =\frac{sum\ of\ reward\ when\ a\ taken\ prior\ to\ t}{number\ of\ times\ a\ taken\ prior\ to\ t}=\frac{\sum_{t=1}^{t-1}{R_i\cdot 1_{A_i=a}}}{\sum_{t=1}^{t-1}{1_{A_i=a}}} \] 其中 \[ 1_{A_i=a}=\left\{ \begin{matrix} 1&amp; if\ A_i=a\\ 0&amp; otherwise\\ \end{matrix} \right. \] 如果分母等于0，就设置 $Q_t( a ) $ 为默认值，例如 $Q_1( a )=0 $ 。当分母趋近于无穷大时，$Q_t( a ) $ 将会收敛于 $q_*( a ) $。 我们称这种方法为sample-average method，这只是比较简单的一种方法，不一定是最好的。 ε-贪婪算法 在第\(t\)次行动，最简单的选择的方式，就是在奖励估计值中选择最大的那个，称之为贪婪方法（greedy） \[ A_t\doteq \underset{a}{arg\max}Q_t\left( a \right) \] 贪婪算法总是选择使得当前取得最大化收益的行动，它并没有管其它行动以后是否会更好。 解决这个问题的办法是，以一个较小的概率\(\epsilon\)，随机选择下一次的行动，而不是一直只选择奖励最大的那个。 这种方法的优点是，随着次数的增加，每个动作将会被抽样无穷大次，从而保证 $Q_t( a ) $ 收敛于 $q_*( a ) $。 假设\(k=10\)，每个老虎机的奖励值从均值为$q_*( a ) $方差为1的高斯分布中选择，如下图所示，进行模拟测试。 figure 1 下图中比较了不同\(\epsilon\)下得到的结果，贪婪算法在一开始比另外两个要快一些，但是随后就停滞不前。较大的\(\epsilon\)能够较快地探索到到最优的动作，但是较小的\(\epsilon\)在最后能得到更好的结果（图上未画出），所以可以考虑随着次数的动态的改变\(\epsilon\)。\(\epsilon\)的大小反映了探索与采用的权衡。 figure 2 ε-greedy算法与具体的任务相关，方差较大时需要更到的探索才能找到最优动作，而方差为0时，贪婪算法从不探索，在尝试一次后就知道奖励的真实值，所以实际上会表现的更好一些。如果该问题是非平稳的（这是经常遇到的），即随着时间的变化，奖励值或者最优动作发生变化，探索性的方法是必要的。 增量实现 令\(R_i\)表示第\(i\)次选择某个行动。\(Q_n\)表示选择该行动执行\(n-1\)后估计的奖励期望值。 \[ Q_n\doteq \frac{R_1+R_2+\cdot \cdot \cdot +R_{n-1}}{n-1} \] 将上式改写为如下形式： \[ Q_{n+1}=Q_n+\frac{1}{n}\left[ R_n-Q_n \right] \] 与第一个公式相比，第二种方式的计算不需要存储最后一次行动之前的奖励值，节省了内存空间。 整个算法流程描述如下： figure 3 类似的更新公式会频繁出现，这里表述为如下形式： \[ NewEstimate←OldEstimate + StepSize \left[ Target−OldEstimate \right] \] 其中\(\left[ Target−OldEstimate \right]\)表示估计中的错误，朝着\(Target\)的方向减少，\(Target\)是假定的移动目标。例如本例中\(Target\)是第\(n\)次行动的奖励值。 步长（\(StepSize\))习惯上记为\(\alpha\)，权值随着学习过程而变化时，记为 \(\alpha _t\)$( a ) $ ，上述算法中取\(\alpha =\frac{1}{n}\)。 非稳定问题 在非平稳问题中，最近的奖励往往比长期的奖励更重要，实现的办法是采用恒定的步长参数。 将\(Q_{n+1}=Q_n+\alpha \left[ R_n-Q_n \right]\)，$( 0,1 ] $ 改写为如下形式： \[ Q_{n+1}=\left( 1-\alpha \right) ^nQ_1+\sum_{i=1}^n{\alpha \left( 1-\alpha \right)}^{n-i}R_i \] 可以看出\(Q_{n+1}​\)是\(Q_1​\)与每个\(R_i​\)的加权平均值。随着\(i​\)的增大，\(R_i​\)的权值以\(1-\alpha​\)为指数增大。这有时被称为\(exponential, recency-weighted~average​\)。 有时候步长参数逐渐发生变化是比较合适的，例如上述算法中的\(\alpha =\frac{1}{n}\)，但并不是所有的\(\left\{ \alpha _n\left( a \right) \right\}\) 都能满足要求。根据随机逼近理论，必须满足如下条件，才能保证估计值收敛于期望的概率逼近1。 \[ \sum_{n=1}^{\infty}{a_n}\left( a \right) =\infty \] \[ \sum_{n=1}^{\infty}{a_n^2}\left( a \right) &lt;\infty \] 第一个条件保证步长足够大以克服初始条件与随机因素的影响，第二个条件保证最终步长的尺寸足够小以收敛。 优化初始值 在上文的公式中可以看出，优化的初始值是\(Q_1 \left( a \right)\)，需要由用户设定，在统计学中称为有偏见的初始估计。 在奖励求平均的方法中偏差会消失，但是其它方法则不一定，但是其权值\(\left( 1-\alpha \right) ^n\)会随着抽样次数的增多而减小，偏差的影响就会越来越小。 假设实际的奖励期望为0，我们取初始值为5，可以鼓励行动-价值算法做出更多探索。 如下图所示，步长取恒定值0.1，贪婪算法取\(Q_1=5\)，\(\epsilon\)-贪婪算法取\(Q_1=0\)。虽然贪婪算法一开始表现并不好，但是其最终结果比\(\epsilon\)-贪婪算法要好很多。 figure 4 我们称这个技巧为\(optimistic~initial~values\)方法，但是这种方法远远不是一种非常有用的方法，也不适用于非平稳问题，不需要太重视。 置信上界选择算法 在\(\epsilon\)-贪婪算法中，最好是根据行动的潜力来探索，而不是不加区别的选择。 置信上界选择算法（UCB）可理解为求每个动作的最大可信值，选择最大可信值最大的行动。 \[ A_t\doteq \underset{a}{arg\max}\left[ Q_t\left( a \right) +c\sqrt{\frac{\log t}{N_t\left( a \right)}} \right] \] 其中\(c\)是控制探索程度的参数，\(N_t\left( a \right)\)表示行动\(a\)被选择的次数。 平方根项表示的是\(a\)值估计的方差或者不确定性，被最大化的量是\(a\)的可能值的上界。每次选择动作\(a\)时，\(a\)的不确定性会减小；选择\(a\)之外的动作时，\(a\)的不确定性会增加。 实验结果如下图： figure 5 梯度算法 上面的算法都是根据奖励的期望值来选择行动，它并非唯一的方法。 对于每个动作\(a\)，我们定义倾向（preference）$H_t( a ) $，倾向性越大，该动作被选择的可能性越大。 利用soft-max函数定义选择动作\(a\)的概率： \[ Pr\left\{ A_t=a \right\} \doteq \frac{e^{H_t\left( a \right)}}{\sum_{b=1}^k{e^{H_t\left( b \right)}}}\doteq \pi _t\left( a \right) \] 初始化每个动作的倾向为0，然后每一步行动\(A_t\)，利用随机梯度上升法更新\(H_t\left( a \right)\)，依据下面的公式： \[ \begin {aligned} H_{t+1}\left( A_t \right)&amp;=H_t\left( A_t \right) +\alpha \left( R_t-\overline{R_t} \right) \left( 1-\pi _t\left( A_t \right) \right) \\ H_{t+1}\left( a \right) &amp;=H_t\left( a \right) -\alpha \left( R_t-\overline{R_t} \right) \pi _t\left( a \right) \ \ \ \forall a\ne A_t \\ \end {aligned} \] 其中\(\overline{R_t}\)是\(t\)时间内所有奖励的均值，即\(\overline{R_t}=\frac{\sum{R_t}}{t}\)，它代表一种基线（baseline），如果\(A_t\)得到的奖励比基线高，那么以后选择该动作的概率会增大，否则便会减小。 该公式是由一般的梯度上升算法推导而来，如下式，具体推导过程参见原文。 \[ H_{t+1}\left( a \right) =H_t\left( a \right) +\alpha \frac{\partial E\left[ R_t \right]}{\partial H_t\left( a \right)} \] 下图为实验结果，其中老虎机的期望奖励的高斯分布均值设为4，便于比较带基线于不带基线（\(\overline{R_t}=0\)）的差别。 figure 6 关联性搜索 假设在学习任务中，每一步的最佳动作随机发生变化，而上述非平稳的方法只适应于变化缓慢的情况。这就需要其它的线索来解决这个问题，除了奖励值以外可以考虑其它相关信息，例如老虎机会发出颜色上的信号，我们可以将其与学习任务关联起来。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chapter 1: The Reinforcement Learning Problem]]></title>
      <url>%2F2017%2F04%2F18%2FChapter-1-The-Reinforcement-Learning-Problem%2F</url>
      <content type="text"><![CDATA[Reinforcement learning : an introduction(Second Edition). 读书笔记 本章主要对增强学习的基本问题做了一个简要的介绍。给出了一些例子，以说明其特点与发展历史。 与环境互动学习是我们知识的主要来源。 这种以目标为导向与不确定的环境进行交互的学习方法，我们称之为增强学习。 与监督学习和非监督学习不同： 监督学习是通过有标签的数据，学习泛化的能力； 非监督学习是通过无标签的数据，找到隐藏的模式。 特点 exploration和exploitation之间的权衡：利用已发现的有效行动、探索未发现的可能更好的行动 考虑整个问题而不是子问题 接近于动物的心理学 实现通用人工智能的一部分 例子 依据与环境交互做出的反馈积累经验，逐渐提高其行为能力 下棋 搅拌控制器在石油提炼操作中逐步优化产量、成本、质量之间的平衡，而不是严格按照工程师最初的设计来操作 机器人进入房间寻找垃圾，寻找一条回去充电的路 小羚羊在出生时挣扎地站起来，然后半小时后每小时能跑几十公里 人类的探索着完成某一项任务的流程方案 组成元素 policy：策略，从感知的环境状态到采取的行为动作的映射，即agent在特定时间下的行为方式 reward signal：奖励信号，增强学习问题的目标，agent可以改变其策略以获得更高的奖励 value function：值函数，从这个状态开始，期望在未来获得的奖励总额 model of environment：环境模型，模拟环境的行为，即在给的动作和状态下，预测下一个状态和奖励 范围和限制 并非所有增强方法都需要值函数。例如遗传算法、基因编程和模拟退火等进化算法十分接近于增强学习，在涉及与环境交互作用的时候，它们忽略了许多问题本身的结构，不关注经历过的状态和采取过的动作，但是当agent不能准确获取环境状态时，这些进化算法又有一定优势。 与优化方法不同，增强学习的目标是最大化奖励，而不是实现优化问题上的最大化。增强学习也会遇到一些不可预料的行为状态，以意想不到的方式获得奖励，换个角度说这属于创造力。 井字游戏 在3x3的棋盘上，某个玩家如果能优先在水平、垂直或者对角上放三个相同的标志即可获胜，类似于下图中的状态属于平局。一个熟练的玩家可以做到从不失手，我们这里假设对手并不完美，能够允许我们赢，在此讨论该问题。 figure 1 经典方法并不能给出令人满意的解决方法，例如游戏理论中的极大极小值（minimax）算法假设了对手特定的下手方式；动态规划的方法又需要输入对手完整的说明，如在每个状态中移动的概率。我们假设这些先验信息是不可用的，需要先学习一个对手行为的模型，再利用动态规划求解。 假设自己执O，对手执X，定义值函数（value function）为赢的概率，学习过程描述如下： 首先构建一个哈希表，代表棋盘上所有可能的状态； 初始化每个状态对应的值函数，其中，赢的状态初始化为1，其它状态初始化为0.5，表示有0.5的概率会赢； 先手和后手依据依据设定的概率选择下面规则之一，轮流执棋，直到该次比赛结束，并保留从exploitation到比赛结束所有的状态序列： exploration：依据值函数的最大值，确定下一步状态； exploitation：随机选择下一状态； 如果赢得比赛，奖励（reward）为1，平局或者失败，奖励为0. 依据下式，在状态序列中倒序更新值函数，其中\(s&#39;\)是\(s\)的下一个状态，\(\alpha\)为更新的步长，首次更新时（\(s\)没有下一状态）取\(V\left(s&#39; \right)\)为reward； \[ V\left( s \right) =V\left( s \right) +\alpha \left[ V\left( s&#39; \right)- V\left( s \right) \right] \] 进行多次比赛，重复3-5步操作，每次都采用上次的更新过的值函数； 一定次数之后完成学习过程。 上述学习过程被称为时间差分学习法（temporal-difference learning method），可用下图描述 figure 2 其中实线表示实际选择的状态，虚线表示经过考虑但是没有选择的状态。\(e^*\)是当时值函数最高的状态，但是我们选择了\(e\)进行探索。箭头指向的是需要保存的状态序列的初始点。 学习完成之后，将状态和值函数表保存起来即可。对弈的时候，通过查找该表实现。 历史 两条主线： 动物学习心理学的试错法(trial-and-error)。 优化控制(optimal control) ，动态编程(dynamic programming)，时间差分(temporal difference)。]]></content>
    </entry>

    
  
  
</search>
